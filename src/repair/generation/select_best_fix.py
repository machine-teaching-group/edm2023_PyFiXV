import sys
from typing import Optional, Sequence, Tuple

sys.path.append(".")

from src.repair.evaluation.metrics import is_parseable
from src.utils.edit_distance_utils import compute_edit_distance
from src.utils.program_utils import program_to_essential_tokens


def filter_by_parseability(generated_fixes: Sequence[str], py_major: int) -> Sequence[str]:
    """
    Input: a list of repairs (generated by Codex).
    Output: keep only the repairs that are parseable.
    """
    parseable_fixes = []

    for fix in generated_fixes:
        if is_parseable(generated_repair=fix, py_major=py_major):
            parseable_fixes.append(fix)

    return parseable_fixes


def select_fix_by_ed(
    buggy_program: str,
    generated_fixes: Sequence[str],
    py_major: int,
) -> Tuple[Optional[str], int, Sequence[str]]:
    """Select the final fixed program: The parseable program with the shortest edit distance to the buggy program"""

    # Get parseable programs
    parseable_fixes = filter_by_parseability(
        generated_fixes=generated_fixes,
        py_major=py_major,
    )
    if len(parseable_fixes) == 0:
        return None, int(1e9), []

    # Select the program with the shortest edit distance
    buggy_tokens = program_to_essential_tokens(buggy_program)
    best_fix, minimum_ed = None, 1e9
    for fix in parseable_fixes:
        ed = compute_edit_distance(buggy_tokens, program_to_essential_tokens(fix))
        if ed < minimum_ed:
            minimum_ed = ed
            best_fix = fix

    return best_fix, minimum_ed, parseable_fixes


if __name__ == "__main__":
    pass
